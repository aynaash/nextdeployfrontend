
---
title: "Monitoring Production Deployments: Metrics That Matter"
description: "Essential monitoring strategies and key metrics for production Next.js applications."
author: "Emily Zhang"
date: "2023-12-28"
tags: ["Monitoring", "Production", "Observability"]
---

import { CodeBlock, Info, Warning, Success } from "@/components/mdx-components"

# Monitoring Production Deployments: Metrics That Matter

Production monitoring is not just about knowing when something breaks—it's about understanding your application's health, performance, and user experience before issues impact your users. This comprehensive guide covers essential monitoring strategies for Next.js applications deployed with NextDeploy.

## The Three Pillars of Observability

Modern application monitoring is built on three fundamental pillars:

### 1. Metrics
Numerical data points that measure system behavior over time.

### 2. Logs
Detailed records of events and transactions within your application.

### 3. Traces
End-to-end request flows showing how requests move through your system.

<Info>
NextDeploy provides built-in support for all three pillars, making it easy to implement comprehensive observability for your Next.js applications.
</Info>

## Essential Metrics for Next.js Applications

### Application Performance Metrics

<CodeBlock title="Key performance indicators" language="javascript">
{`// Essential metrics to track
const applicationMetrics = {
  // Response time metrics
  responseTime: {
    p50: 'median response time',
    p95: '95th percentile response time',
    p99: '99th percentile response time',
    max: 'maximum response time'
  },

  // Throughput metrics
  throughput: {
    requestsPerSecond: 'total requests per second',
    requestsPerMinute: 'requests per minute by endpoint',
    concurrentUsers: 'active concurrent users'
  },

  // Error metrics
  errors: {
    errorRate: 'percentage of failed requests',
    errorsByType: 'errors grouped by type/status code',
    errorsByEndpoint: 'errors per API endpoint'
  },

  // Business metrics
  business: {
    conversionRate: 'user conversion percentage',
    userSessions: 'active user sessions',
    featureUsage: 'feature adoption rates'
  }
}`}
</CodeBlock>

### Infrastructure Metrics

<CodeBlock title="Infrastructure monitoring" language="javascript">
{`// System-level metrics
const infrastructureMetrics = {
  // CPU metrics
  cpu: {
    usage: 'CPU utilization percentage',
    loadAverage: 'system load average',
    processes: 'running process count'
  },

  // Memory metrics
  memory: {
    usage: 'memory utilization percentage',
    available: 'available memory',
    heapUsage: 'Node.js heap usage',
    gcFrequency: 'garbage collection frequency'
  },

  // Disk metrics
  disk: {
    usage: 'disk space utilization',
    ioOperations: 'disk I/O operations per second',
    ioLatency: 'disk I/O latency'
  },

  // Network metrics
  network: {
    bandwidth: 'network bandwidth usage',
    connections: 'active network connections',
    latency: 'network latency'
  }
}`}
</CodeBlock>

## Implementing Metrics Collection

### Application-Level Monitoring

<CodeBlock title="src/lib/metrics.ts" language="typescript">
{`import { performance } from 'perf_hooks'

interface MetricData {
  name: string
  value: number
  timestamp: number
  tags?: Record<string, string>
}

class MetricsCollector {
  private metrics: MetricData[] = []
  private timers: Map<string, number> = new Map()

  // Counter metrics
  increment(name: string, value: number = 1, tags?: Record<string, string>) {
    this.metrics.push({
      name,
      value,
      timestamp: Date.now(),
      tags
    })
  }

  // Gauge metrics
  gauge(name: string, value: number, tags?: Record<string, string>) {
    this.metrics.push({
      name,
      value,
      timestamp: Date.now(),
      tags
    })
  }

  // Timing metrics
  startTimer(name: string) {
    this.timers.set(name, performance.now())
  }

  endTimer(name: string, tags?: Record<string, string>) {
    const startTime = this.timers.get(name)
    if (startTime) {
      const duration = performance.now() - startTime
      this.gauge(name, duration, tags)
      this.timers.delete(name)
    }
  }

  // Histogram metrics
  histogram(name: string, value: number, tags?: Record<string, string>) {
    this.metrics.push({
      name: \`\${name}_histogram\`,
      value,
      timestamp: Date.now(),
      tags
    })
  }

  // Get all metrics
  getMetrics(): MetricData[] {
    return [...this.metrics]
  }

  // Clear metrics
  clear() {
    this.metrics = []
  }

  // Export metrics in Prometheus format
  exportPrometheus(): string {
    const grouped = this.groupMetricsByName()
    let output = ''

    for (const [name, metrics] of grouped) {
      output += \`# HELP \${name} Application metric\\n\`
      output += \`# TYPE \${name} gauge\\n\`
      
      for (const metric of metrics) {
        const tags = metric.tags 
          ? Object.entries(metric.tags)
              .map(([k, v]) => \`\${k}="\${v}"\`)
              .join(',')
          : ''
        
        output += \`\${name}\${tags ? \`{\${tags}}\` : ''} \${metric.value} \${metric.timestamp}\\n\`
      }
    }

    return output
  }

  private groupMetricsByName(): Map<string, MetricData[]> {
    const grouped = new Map<string, MetricData[]>()
    
    for (const metric of this.metrics) {
      if (!grouped.has(metric.name)) {
        grouped.set(metric.name, [])
      }
      grouped.get(metric.name)!.push(metric)
    }

    return grouped
  }
}

export const metrics = new MetricsCollector()

// Middleware for automatic request tracking
export function metricsMiddleware(req: any, res: any, next: any) {
  const startTime = performance.now()
  const timerName = \`http_request_\${Date.now()}\`
  
  metrics.startTimer(timerName)
  metrics.increment('http_requests_total', 1, {
    method: req.method,
    route: req.route?.path || req.path
  })

  res.on('finish', () => {
    metrics.endTimer(timerName, {
      method: req.method,
      status: res.statusCode.toString(),
      route: req.route?.path || req.path
    })

    metrics.increment('http_requests_completed', 1, {
      method: req.method,
      status: res.statusCode.toString()
    })

    if (res.statusCode >= 400) {
      metrics.increment('http_errors_total', 1, {
        method: req.method,
        status: res.statusCode.toString()
      })
    }
  })

  next()
}`}
</CodeBlock>

### Metrics API Endpoint

<CodeBlock title="src/app/api/metrics/route.ts" language="typescript">
{`import { NextResponse } from 'next/server'
import { metrics } from '@/lib/metrics'

export async function GET() {
  try {
    // Collect current system metrics
    const systemMetrics = {
      memory: process.memoryUsage(),
      uptime: process.uptime(),
      cpu: process.cpuUsage(),
      version: process.version,
      platform: process.platform
    }

    // Add system metrics to collector
    metrics.gauge('nodejs_memory_heap_used_bytes', systemMetrics.memory.heapUsed)
    metrics.gauge('nodejs_memory_heap_total_bytes', systemMetrics.memory.heapTotal)
    metrics.gauge('nodejs_memory_external_bytes', systemMetrics.memory.external)
    metrics.gauge('nodejs_uptime_seconds', systemMetrics.uptime)

    // Return metrics in Prometheus format
    const prometheusMetrics = metrics.exportPrometheus()
    
    return new NextResponse(prometheusMetrics, {
      headers: {
        'Content-Type': 'text/plain; version=0.0.4; charset=utf-8'
      }
    })
  } catch (error) {
    console.error('Error collecting metrics:', error)
    return NextResponse.json(
      { error: 'Failed to collect metrics' },
      { status: 500 }
    )
  }
}

// Health check with metrics
export async function POST() {
  try {
    const healthData = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      checks: {
        database: await checkDatabase(),
        cache: await checkCache(),
        externalServices: await checkExternalServices()
      }
    }

    // Record health check metrics
    metrics.increment('health_checks_total', 1)
    
    Object.entries(healthData.checks).forEach(([service, status]) => {
      metrics.gauge('service_health', status === 'healthy' ? 1 : 0, {
        service
      })
    })

    return NextResponse.json(healthData)
  } catch (error) {
    metrics.increment('health_check_errors_total', 1)
    return NextResponse.json(
      { status: 'unhealthy', error: error.message },
      { status: 503 }
    )
  }
}

async function checkDatabase(): Promise<string> {
  // Implement database health check
  try {
    // Example: await db.query('SELECT 1')
    return 'healthy'
  } catch {
    return 'unhealthy'
  }
}

async function checkCache(): Promise<string> {
  // Implement cache health check
  try {
    // Example: await redis.ping()
    return 'healthy'
  } catch {
    return 'unhealthy'
  }
}

async function checkExternalServices(): Promise<string> {
  // Implement external service checks
  try {
    // Example: check API endpoints, third-party services
    return 'healthy'
  } catch {
    return 'unhealthy'
  }
}`}
</CodeBlock>

## Structured Logging

### Implementing Structured Logging

<CodeBlock title="src/lib/logger.ts" language="typescript">
{`import { metrics } from './metrics'

export enum LogLevel {
  ERROR = 0,
  WARN = 1,
  INFO = 2,
  DEBUG = 3
}

interface LogEntry {
  timestamp: string
  level: string
  message: string
  context?: string
  data?: any
  requestId?: string
  userId?: string
  sessionId?: string
  traceId?: string
  spanId?: string
}

class Logger {
  private level: LogLevel
  private context: string

  constructor(context: string = 'App', level: LogLevel = LogLevel.INFO) {
    this.context = context
    this.level = level
  }

  private shouldLog(level: LogLevel): boolean {
    return level <= this.level
  }

  private formatLog(level: LogLevel, message: string, data?: any): LogEntry {
    return {
      timestamp: new Date().toISOString(),
      level: LogLevel[level],
      message,
      context: this.context,
      ...(data && { data }),
      // Add request context if available
      requestId: this.getRequestId(),
      userId: this.getUserId(),
      sessionId: this.getSessionId(),
      traceId: this.getTraceId(),
      spanId: this.getSpanId()
    }
  }

  private output(logEntry: LogEntry) {
    const logString = JSON.stringify(logEntry)
    
    if (logEntry.level === 'ERROR') {
      console.error(logString)
      metrics.increment('log_entries_total', 1, { level: 'error' })
    } else if (logEntry.level === 'WARN') {
      console.warn(logString)
      metrics.increment('log_entries_total', 1, { level: 'warn' })
    } else {
      console.log(logString)
      metrics.increment('log_entries_total', 1, { level: logEntry.level.toLowerCase() })
    }
  }

  error(message: string, error?: Error | any) {
    if (!this.shouldLog(LogLevel.ERROR)) return

    const logData = error instanceof Error ? {
      name: error.name,
      message: error.message,
      stack: error.stack,
      ...(error.cause && { cause: error.cause })
    } : error

    this.output(this.formatLog(LogLevel.ERROR, message, logData))
  }

  warn(message: string, data?: any) {
    if (!this.shouldLog(LogLevel.WARN)) return
    this.output(this.formatLog(LogLevel.WARN, message, data))
  }

  info(message: string, data?: any) {
    if (!this.shouldLog(LogLevel.INFO)) return
    this.output(this.formatLog(LogLevel.INFO, message, data))
  }

  debug(message: string, data?: any) {
    if (!this.shouldLog(LogLevel.DEBUG)) return
    this.output(this.formatLog(LogLevel.DEBUG, message, data))
  }

  // Performance logging
  time(label: string, data?: any) {
    this.debug(\`Timer started: \${label}\`, data)
    console.time(label)
  }

  timeEnd(label: string, data?: any) {
    console.timeEnd(label)
    this.debug(\`Timer ended: \${label}\`, data)
  }

  // Request logging
  logRequest(req: any, res: any, duration: number) {
    this.info('HTTP Request', {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration: \`\${duration}ms\`,
      userAgent: req.headers['user-agent'],
      ip: req.headers['x-forwarded-for'] || req.connection?.remoteAddress,
      contentLength: res.get('content-length')
    })
  }

  // Business event logging
  logBusinessEvent(event: string, data?: any) {
    this.info(\`Business Event: \${event}\`, data)
    metrics.increment('business_events_total', 1, { event })
  }

  // Security event logging
  logSecurityEvent(event: string, data?: any) {
    this.warn(\`Security Event: \${event}\`, data)
    metrics.increment('security_events_total', 1, { event })
  }

  // Helper methods to get context (implement based on your setup)
  private getRequestId(): string | undefined {
    // Implementation depends on your request context setup
    return undefined
  }

  private getUserId(): string | undefined {
    // Implementation depends on your authentication setup
    return undefined
  }

  private getSessionId(): string | undefined {
    // Implementation depends on your session management
    return undefined
  }

  private getTraceId(): string | undefined {
    // Implementation depends on your tracing setup
    return undefined
  }

  private getSpanId(): string | undefined {
    // Implementation depends on your tracing setup
    return undefined
  }
}

export const logger = new Logger('NextApp', LogLevel.INFO)
export default Logger`}
</CodeBlock>

## Alerting and Notifications

### Alert Configuration

<CodeBlock title="Alert rules configuration" language="javascript">
{`// monitoring/alerts.js
module.exports = {
  alerts: [
    {
      name: 'High Error Rate',
      description: 'Application error rate is above threshold',
      condition: {
        metric: 'http_errors_total',
        operator: 'rate',
        threshold: 0.05, // 5% error rate
        duration: '5m'
      },
      severity: 'critical',
      notifications: ['email', 'slack'],
      runbook: 'https://docs.company.com/runbooks/high-error-rate'
    },

    {
      name: 'High Response Time',
      description: '95th percentile response time is too high',
      condition: {
        metric: 'http_request_duration_p95',
        operator: 'gt',
        threshold: 2000, // 2 seconds
        duration: '10m'
      },
      severity: 'warning',
      notifications: ['slack'],
      runbook: 'https://docs.company.com/runbooks/high-response-time'
    },

    {
      name: 'Memory Usage High',
      description: 'Application memory usage is approaching limits',
      condition: {
        metric: 'nodejs_memory_heap_used_bytes',
        operator: 'gt',
        threshold: 1073741824, // 1GB
        duration: '5m'
      },
      severity: 'warning',
      notifications: ['email'],
      runbook: 'https://docs.company.com/runbooks/memory-usage'
    },

    {
      name: 'Service Down',
      description: 'Application health check is failing',
      condition: {
        metric: 'service_health',
        operator: 'eq',
        threshold: 0,
        duration: '1m'
      },
      severity: 'critical',
      notifications: ['email', 'slack', 'pagerduty'],
      runbook: 'https://docs.company.com/runbooks/service-down'
    },

    {
      name: 'Disk Space Low',
      description: 'Disk space is running low',
      condition: {
        metric: 'disk_usage_percent',
        operator: 'gt',
        threshold: 85,
        duration: '15m'
      },
      severity: 'warning',
      notifications: ['email'],
      runbook: 'https://docs.company.com/runbooks/disk-space'
    }
  ],

  notifications: {
    email: {
      enabled: true,
      recipients: ['devops@company.com', 'oncall@company.com'],
      smtp: {
        host: process.env.SMTP_HOST,
        port: 587,
        secure: false,
        auth: {
          user: process.env.SMTP_USER,
          pass: process.env.SMTP_PASS
        }
      }
    },

    slack: {
      enabled: true,
      webhook: process.env.SLACK_WEBHOOK_URL,
      channel: '#alerts',
      username: 'NextDeploy Monitor'
    },

    pagerduty: {
      enabled: true,
      integrationKey: process.env.PAGERDUTY_INTEGRATION_KEY,
      severity: 'critical'
    }
  }
}`}
</CodeBlock>

### Alert Manager Implementation

<CodeBlock title="src/lib/alerting.ts" language="typescript">
{`import { logger } from './logger'
import { metrics } from './metrics'

interface Alert {
  name: string
  description: string
  severity: 'info' | 'warning' | 'critical'
  timestamp: number
  value: number
  threshold: number
  runbook?: string
}

interface NotificationChannel {
  type: 'email' | 'slack' | 'webhook'
  config: any
}

class AlertManager {
  private activeAlerts: Map<string, Alert> = new Map()
  private alertHistory: Alert[] = []

  async checkAlert(
    name: string,
    value: number,
    threshold: number,
    operator: 'gt' | 'lt' | 'eq' | 'ne' = 'gt',
    severity: 'info' | 'warning' | 'critical' = 'warning'
  ) {
    const isTriggered = this.evaluateCondition(value, threshold, operator)
    const alertKey = \`\${name}_\${severity}\`

    if (isTriggered && !this.activeAlerts.has(alertKey)) {
      // New alert triggered
      const alert: Alert = {
        name,
        description: \`\${name} threshold exceeded\`,
        severity,
        timestamp: Date.now(),
        value,
        threshold
      }

      this.activeAlerts.set(alertKey, alert)
      this.alertHistory.push(alert)
      
      await this.sendNotification(alert)
      
      logger.warn('Alert triggered', {
        alert: alertKey,
        value,
        threshold,
        severity
      })

      metrics.increment('alerts_triggered_total', 1, {
        alert: name,
        severity
      })

    } else if (!isTriggered && this.activeAlerts.has(alertKey)) {
      // Alert resolved
      const alert = this.activeAlerts.get(alertKey)!
      this.activeAlerts.delete(alertKey)
      
      await this.sendResolutionNotification(alert)
      
      logger.info('Alert resolved', {
        alert: alertKey,
        value,
        threshold
      })

      metrics.increment('alerts_resolved_total', 1, {
        alert: name,
        severity
      })
    }
  }

  private evaluateCondition(
    value: number,
    threshold: number,
    operator: 'gt' | 'lt' | 'eq' | 'ne'
  ): boolean {
    switch (operator) {
      case 'gt': return value > threshold
      case 'lt': return value < threshold
      case 'eq': return value === threshold
      case 'ne': return value !== threshold
      default: return false
    }
  }

  private async sendNotification(alert: Alert) {
    const channels = this.getNotificationChannels(alert.severity)
    
    for (const channel of channels) {
      try {
        await this.sendToChannel(channel, alert)
      } catch (error) {
        logger.error('Failed to send alert notification', {
          channel: channel.type,
          alert: alert.name,
          error
        })
      }
    }
  }

  private async sendResolutionNotification(alert: Alert) {
    const channels = this.getNotificationChannels(alert.severity)
    
    for (const channel of channels) {
      try {
        await this.sendResolutionToChannel(channel, alert)
      } catch (error) {
        logger.error('Failed to send resolution notification', {
          channel: channel.type,
          alert: alert.name,
          error
        })
      }
    }
  }

  private getNotificationChannels(severity: string): NotificationChannel[] {
    const channels: NotificationChannel[] = []

    // Always send to email for critical alerts
    if (severity === 'critical') {
      channels.push({
        type: 'email',
        config: {
          recipients: ['oncall@company.com'],
          subject: 'CRITICAL ALERT'
        }
      })
    }

    // Send to Slack for all alerts
    channels.push({
      type: 'slack',
      config: {
        webhook: process.env.SLACK_WEBHOOK_URL,
        channel: '#alerts'
      }
    })

    return channels
  }

  private async sendToChannel(channel: NotificationChannel, alert: Alert) {
    switch (channel.type) {
      case 'email':
        await this.sendEmail(channel.config, alert)
        break
      case 'slack':
        await this.sendSlack(channel.config, alert)
        break
      case 'webhook':
        await this.sendWebhook(channel.config, alert)
        break
    }
  }

  private async sendResolutionToChannel(channel: NotificationChannel, alert: Alert) {
    // Similar to sendToChannel but for resolution messages
    const resolutionMessage = \`✅ RESOLVED: \${alert.name}\`
    // Implementation details...
  }

  private async sendEmail(config: any, alert: Alert) {
    // Email implementation
    logger.debug('Sending email alert', { alert: alert.name })
  }

  private async sendSlack(config: any, alert: Alert) {
    const payload = {
      channel: config.channel,
      username: 'NextDeploy Monitor',
      icon_emoji: alert.severity === 'critical' ? ':rotating_light:' : ':warning:',
      attachments: [{
        color: alert.severity === 'critical' ? 'danger' : 'warning',
        title: \`\${alert.severity.toUpperCase()}: \${alert.name}\`,
        text: alert.description,
        fields: [
          {
            title: 'Value',
            value: alert.value.toString(),
            short: true
          },
          {
            title: 'Threshold',
            value: alert.threshold.toString(),
            short: true
          },
          {
            title: 'Time',
            value: new Date(alert.timestamp).toISOString(),
            short: true
          }
        ]
      }]
    }

    const response = await fetch(config.webhook, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })

    if (!response.ok) {
      throw new Error(\`Slack notification failed: \${response.statusText}\`)
    }
  }

  private async sendWebhook(config: any, alert: Alert) {
    // Webhook implementation
    logger.debug('Sending webhook alert', { alert: alert.name })
  }

  getActiveAlerts(): Alert[] {
    return Array.from(this.activeAlerts.values())
  }

  getAlertHistory(limit: number = 100): Alert[] {
    return this.alertHistory.slice(-limit)
  }
}

export const alertManager = new AlertManager()`}
</CodeBlock>

## Dashboard Creation

### Monitoring Dashboard

<CodeBlock title="src/app/admin/monitoring/page.tsx" language="typescript">
{`'use client'

import { useEffect, useState } from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Progress } from '@/components/ui/progress'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { Activity, Server, Zap, AlertTriangle, CheckCircle, Clock, TrendingUp, TrendingDown } from 'lucide-react'

interface SystemMetrics {
  timestamp: string
  application: {
    responseTime: {
      p50: number
      p95: number
      p99: number
    }
    throughput: {
      requestsPerSecond: number
      requestsPerMinute: number
    }
    errors: {
      rate: number
      total: number
    }
  }
  infrastructure: {
    cpu: {
      usage: number
      loadAverage: number[]
    }
    memory: {
      usage: number
      total: number
      used: number
    }
    disk: {
      usage: number
      total: number
      used: number
    }
  }
  health: {
    status: 'healthy' | 'degraded' | 'unhealthy'
    checks: Record<string, boolean>
  }
}

interface AlertData {
  name: string
  severity: 'info' | 'warning' | 'critical'
  description: string
  timestamp: number
  active: boolean
}

export default function MonitoringDashboard() {
  const [metrics, setMetrics] = useState<SystemMetrics | null>(null)
  const [alerts, setAlerts] = useState<AlertData[]>([])
  const [loading, setLoading] = useState(true)
  const [lastUpdate, setLastUpdate] = useState<Date>(new Date())

  useEffect(() => {
    const fetchData = async () => {
      try {
        const [metricsResponse, alertsResponse] = await Promise.all([
          fetch('/api/metrics/dashboard'),
          fetch('/api/alerts')
        ])

        const metricsData = await metricsResponse.json()
        const alertsData = await alertsResponse.json()

        setMetrics(metricsData)
        setAlerts(alertsData)
        setLastUpdate(new Date())
      } catch (error) {
        console.error('Failed to fetch monitoring data:', error)
      } finally {
        setLoading(false)
      }
    }

    fetchData()
    const interval = setInterval(fetchData, 30000) // Update every 30 seconds

    return () => clearInterval(interval)
  }, [])

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <Activity className="h-8 w-8 animate-spin mx-auto mb-4" />
          <p>Loading monitoring data...</p>
        </div>
      </div>
    )
  }

  if (!metrics) {
    return (
      <div className="flex items-center justify-center h-64">
        <Alert>
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>
            Failed to load monitoring data. Please check your connection and try again.
          </AlertDescription>
        </Alert>
      </div>
    )
  }

  const getHealthStatusColor = (status: string) => {
    switch (status) {
      case 'healthy': return 'text-green-600'
      case 'degraded': return 'text-yellow-600'
      case 'unhealthy': return 'text-red-600'
      default: return 'text-gray-600'
    }
  }

  const getHealthStatusIcon = (status: string) => {
    switch (status) {
      case 'healthy': return <CheckCircle className="h-4 w-4 text-green-600" />
      case 'degraded': return <AlertTriangle className="h-4 w-4 text-yellow-600" />
      case 'unhealthy': return <AlertTriangle className="h-4 w-4 text-red-600" />
      default: return <Server className="h-4 w-4 text-gray-600" />
    }
  }

  const formatBytes = (bytes: number) => {
    const gb = bytes / 1024 / 1024 / 1024
    return `${gb.toFixed(1)} GB`
  }

  const formatPercentage = (value: number) => {
    return `${value.toFixed(1)}%`
  }

  const activeAlerts = alerts.filter(alert => alert.active)
  const criticalAlerts = activeAlerts.filter(alert => alert.severity === 'critical')

  return (
    <div className="container mx-auto py-8 space-y-8">
      {/* Header */}
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold">System Monitoring</h1>
          <p className="text-muted-foreground">
            Last updated: {lastUpdate.toLocaleTimeString()}
          </p>
        </div>
        <div className="flex items-center space-x-2">
          {getHealthStatusIcon(metrics.health.status)}
          <span className={`font-medium ${getHealthStatusColor(metrics.health.status)}`}>
            {metrics.health.status.toUpperCase()}
          </span>
        </div>
      </div>

      {/* Active Alerts */}
      {activeAlerts.length > 0 && (
        <div className="space-y-4">
          <h2 className="text-xl font-semibold flex items-center">
            <AlertTriangle className="h-5 w-5 mr-2 text-red-600" />
            Active Alerts ({activeAlerts.length})
          </h2>
          <div className="grid gap-4">
            {activeAlerts.map((alert, index) => (
              <Alert key={index} className={`border-l-4 ${
                alert.severity === 'critical' ? 'border-l-red-500 bg-red-50 dark:bg-red-900/10' :
                alert.severity === 'warning' ? 'border-l-yellow-500 bg-yellow-50 dark:bg-yellow-900/10' :
                'border-l-blue-500 bg-blue-50 dark:bg-blue-900/10'
              }`}>
                <div className="flex justify-between items-start">
                  <div>
                    <div className="flex items-center space-x-2">
                      <Badge variant={alert.severity === 'critical' ? 'destructive' : 'secondary'}>
                        {alert.severity.toUpperCase()}
                      </Badge>
                      <span className="font-semibold">{alert.name}</span>
                    </div>
                    <AlertDescription className="mt-1">
                      {alert.description}
                    </AlertDescription>
                  </div>
                  <div className="text-sm text-muted-foreground">
                    {new Date(alert.timestamp).toLocaleTimeString()}
                  </div>
                </div>
              </Alert>
            ))}
          </div>
        </div>
      )}

      {/* Key Metrics Overview */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        {/* Response Time */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Response Time (P95)</CardTitle>
            <Zap className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {metrics.application.responseTime.p95}ms
            </div>
            <div className="flex items-center text-xs text-muted-foreground mt-1">
              {metrics.application.responseTime.p95 < 1000 ? (
                <TrendingDown className="h-3 w-3 text-green-600 mr-1" />
              ) : (
                <TrendingUp className="h-3 w-3 text-red-600 mr-1" />
              )}
              P50: {metrics.application.responseTime.p50}ms
            </div>
          </CardContent>
        </Card>

        {/* Throughput */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Requests/sec</CardTitle>
            <Activity className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {metrics.application.throughput.requestsPerSecond}
            </div>
            <p className="text-xs text-muted-foreground">
              {metrics.application.throughput.requestsPerMinute}/min
            </p>
          </CardContent>
        </Card>

        {/* Error Rate */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Error Rate</CardTitle>
            <AlertTriangle className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {formatPercentage(metrics.application.errors.rate)}
            </div>
            <p className="text-xs text-muted-foreground">
              {metrics.application.errors.total} total errors
            </p>
          </CardContent>
        </Card>

        {/* System Health */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">System Health</CardTitle>
            <Server className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className={`text-2xl font-bold ${getHealthStatusColor(metrics.health.status)}`}>
              {metrics.health.status}
            </div>
            <p className="text-xs text-muted-foreground">
              {Object.values(metrics.health.checks).filter(Boolean).length}/
              {Object.keys(metrics.health.checks).length} services healthy
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Resource Usage */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* CPU Usage */}
        <Card>
          <CardHeader>
            <CardTitle>CPU Usage</CardTitle>
            <CardDescription>Current CPU utilization</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex justify-between text-sm">
              <span>Usage</span>
              <span>{formatPercentage(metrics.infrastructure.cpu.usage)}</span>
            </div>
            <Progress value={metrics.infrastructure.cpu.usage} className="h-2" />
            <div className="text-xs text-muted-foreground">
              Load Average: {metrics.infrastructure.cpu.loadAverage.map(l => l.toFixed(2)).join(', ')}
            </div>
          </CardContent>
        </Card>

        {/* Memory Usage */}
        <Card>
          <CardHeader>
            <CardTitle>Memory Usage</CardTitle>
            <CardDescription>RAM utilization</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex justify-between text-sm">
              <span>Used</span>
              <span>{formatBytes(metrics.infrastructure.memory.used)} / {formatBytes(metrics.infrastructure.memory.total)}</span>
            </div>
            <Progress value={metrics.infrastructure.memory.usage} className="h-2" />
            <div className="text-xs text-muted-foreground">
              {formatPercentage(metrics.infrastructure.memory.usage)} utilized
            </div>
          </CardContent>
        </Card>

        {/* Disk Usage */}
        <Card>
          <CardHeader>
            <CardTitle>Disk Usage</CardTitle>
            <CardDescription>Storage utilization</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex justify-between text-sm">
              <span>Used</span>
              <span>{formatBytes(metrics.infrastructure.disk.used)} / {formatBytes(metrics.infrastructure.disk.total)}</span>
            </div>
            <Progress value={metrics.infrastructure.disk.usage} className="h-2" />
            <div className="text-xs text-muted-foreground">
              {formatPercentage(metrics.infrastructure.disk.usage)} utilized
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Service Health Checks */}
      <Card>
        <CardHeader>
          <CardTitle>Service Health Checks</CardTitle>
          <CardDescription>Status of individual service components</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {Object.entries(metrics.health.checks).map(([service, healthy]) => (
              <div key={service} className="flex items-center space-x-2">
                {healthy ? (
                  <CheckCircle className="h-4 w-4 text-green-600" />
                ) : (
                  <AlertTriangle className="h-4 w-4 text-red-600" />
                )}
                <span className="text-sm capitalize">{service}</span>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}`}
</CodeBlock>

## Performance Optimization Based on Metrics

### Automated Performance Tuning

<CodeBlock title="src/lib/performance-optimizer.ts" language="typescript">
{`import { metrics } from './metrics'
import { logger } from './logger'
import { alertManager } from './alerting'

interface OptimizationRule {
  name: string
  condition: (metrics: any) => boolean
  action: () => Promise<void>
  cooldown: number // milliseconds
  lastExecuted?: number
}

class PerformanceOptimizer {
  private rules: OptimizationRule[] = []
  private isRunning = false

  constructor() {
    this.setupOptimizationRules()
  }

  private setupOptimizationRules() {
    this.rules = [
      {
        name: 'Memory Cleanup',
        condition: (metrics) => metrics.memory.heapUsed > 500 * 1024 * 1024, // 500MB
        action: this.performMemoryCleanup,
        cooldown: 5 * 60 * 1000 // 5 minutes
      },
      {
        name: 'Cache Optimization',
        condition: (metrics) => metrics.responseTime.p95 > 2000, // 2 seconds
        action: this.optimizeCache,
        cooldown: 10 * 60 * 1000 // 10 minutes
      },
      {
        name: 'Connection Pool Adjustment',
        condition: (metrics) => metrics.activeConnections > 100,
        action: this.adjustConnectionPool,
        cooldown: 15 * 60 * 1000 // 15 minutes
      }
    ]
  }

  async runOptimizations() {
    if (this.isRunning) return

    this.isRunning = true
    
    try {
      const currentMetrics = await this.getCurrentMetrics()
      
      for (const rule of this.rules) {
        if (this.shouldExecuteRule(rule, currentMetrics)) {
          await this.executeRule(rule)
        }
      }
    } catch (error) {
      logger.error('Performance optimization failed', error)
    } finally {
      this.isRunning = false
    }
  }

  private shouldExecuteRule(rule: OptimizationRule, metrics: any): boolean {
    // Check if condition is met
    if (!rule.condition(metrics)) return false

    // Check cooldown period
    if (rule.lastExecuted && Date.now() - rule.lastExecuted < rule.cooldown) {
      return false
    }

    return true
  }

  private async executeRule(rule: OptimizationRule) {
    try {
      logger.info(`Executing optimization rule: ${rule.name}`)
      
      await rule.action()
      
      rule.lastExecuted = Date.now()
      
      metrics.increment('optimizations_executed_total', 1, {
        rule: rule.name
      })
      
      logger.info(`Optimization rule completed: ${rule.name}`)
    } catch (error) {
      logger.error(`Optimization rule failed: ${rule.name}`, error)
      
      metrics.increment('optimizations_failed_total', 1, {
        rule: rule.name
      })
    }
  }

  private async getCurrentMetrics() {
    return {
      memory: process.memoryUsage(),
      responseTime: await this.getResponseTimeMetrics(),
      activeConnections: await this.getActiveConnections()
    }
  }

  private async getResponseTimeMetrics() {
    // Implementation to get current response time metrics
    return { p95: 1500 } // placeholder
  }

  private async getActiveConnections() {
    // Implementation to get active connection count
    return 50 // placeholder
  }

  private async performMemoryCleanup() {
    logger.info('Performing memory cleanup')
    
    // Force garbage collection if available
    if (global.gc) {
      global.gc()
    }
    
    // Clear application caches
    await this.clearApplicationCaches()
    
    // Log memory usage after cleanup
    const memoryAfter = process.memoryUsage()
    logger.info('Memory cleanup completed', {
      heapUsed: memoryAfter.heapUsed,
      heapTotal: memoryAfter.heapTotal
    })
  }

  private async optimizeCache() {
    logger.info('Optimizing cache performance')
    
    // Implement cache optimization logic
    // This could include:
    // - Preloading frequently accessed data
    // - Adjusting cache TTL values
    // - Clearing stale cache entries
    
    logger.info('Cache optimization completed')
  }

  private async adjustConnectionPool() {
    logger.info('Adjusting connection pool settings')
    
    // Implement connection pool optimization
    // This could include:
    // - Increasing pool size
    // - Adjusting timeout values
    // - Closing idle connections
    
    logger.info('Connection pool adjustment completed')
  }

  private async clearApplicationCaches() {
    // Implementation to clear various application caches
    logger.debug('Clearing application caches')
  }
}

export const performanceOptimizer = new PerformanceOptimizer()

// Schedule regular optimization runs
setInterval(() => {
  performanceOptimizer.runOptimizations()
}, 5 * 60 * 1000) // Run every 5 minutes`}
</CodeBlock>

## Conclusion

Effective monitoring is crucial for maintaining healthy production applications. By implementing comprehensive metrics collection, structured logging, proactive alerting, and automated optimization, you can:

<Success>
- **Detect issues before they impact users**
- **Understand application performance patterns**
- **Make data-driven optimization decisions**
- **Maintain high availability and reliability**
- **Reduce mean time to resolution (MTTR)**
</Success>

## Best Practices Summary

1. **Monitor the Right Metrics**: Focus on user-impacting metrics like response time, error rate, and availability
2. **Set Meaningful Alerts**: Avoid alert fatigue by setting appropriate thresholds and using escalation policies
3. **Use Structured Logging**: Make logs searchable and actionable with consistent structure
4. **Implement Health Checks**: Provide detailed health information for automated monitoring
5. **Plan for Scale**: Design monitoring systems that can handle growth in traffic and data
6. **Document Runbooks**: Provide clear procedures for responding to alerts
7. **Regular Review**: Continuously evaluate and improve your monitoring strategy

## Next Steps

1. **Implement basic metrics collection** in your Next.js application
2. **Set up structured logging** with appropriate log levels
3. **Configure essential alerts** for critical system metrics
4. **Create monitoring dashboards** for visibility
5. **Establish incident response procedures** with clear runbooks
6. **Test your monitoring** with chaos engineering practices

Ready to implement comprehensive monitoring? Check out our [VPS Deployment Course](/courses/deploying-nextjs-to-vps) where we cover monitoring setup in detail, or explore our [Infrastructure as Code guide](/blog/infrastructure-as-code-best-practices) for managing monitoring configuration.

Remember: monitoring is not a one-time setup—it's an ongoing practice that evolves with your application and business needs.
\`\`\`

Now let me update the components to read from these MDX files:

\`\`\`
