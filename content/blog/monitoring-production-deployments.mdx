
---
title: "Monitoring Production Deployments: Metrics That Matter"
description: "Essential monitoring strategies and key metrics for production Next.js applications."
author: "Emily Zhang"
date: "2023-12-28"
tags: ["Monitoring", "Production", "Observability"]
---

import { CodeBlock, Info, Warning, Success } from "@/components/mdx-components"

# Monitoring Production Deployments: Metrics That Matter

Production monitoring is not just about knowing when something breaksâ€”it's about understanding your application's health, performance, and user experience before issues impact your users. This comprehensive guide covers essential monitoring strategies for Next.js applications deployed with NextDeploy.

## The Three Pillars of Observability

Modern application monitoring is built on three fundamental pillars:

### 1. Metrics
Numerical data points that measure system behavior over time.

### 2. Logs
Detailed records of events and transactions within your application.

### 3. Traces
End-to-end request flows showing how requests move through your system.

<Info>
NextDeploy provides built-in support for all three pillars, making it easy to implement comprehensive observability for your Next.js applications.
</Info>

## Essential Metrics for Next.js Applications

### Application Performance Metrics

<CodeBlock title="Key performance indicators" language="javascript">
{`// Essential metrics to track
const applicationMetrics = {
  // Response time metrics
  responseTime: {
    p50: 'median response time',
    p95: '95th percentile response time',
    p99: '99th percentile response time',
    max: 'maximum response time'
  },

  // Throughput metrics
  throughput: {
    requestsPerSecond: 'total requests per second',
    requestsPerMinute: 'requests per minute by endpoint',
    concurrentUsers: 'active concurrent users'
  },

  // Error metrics
  errors: {
    errorRate: 'percentage of failed requests',
    errorsByType: 'errors grouped by type/status code',
    errorsByEndpoint: 'errors per API endpoint'
  },

  // Business metrics
  business: {
    conversionRate: 'user conversion percentage',
    userSessions: 'active user sessions',
    featureUsage: 'feature adoption rates'
  }
}`}
</CodeBlock>

### Infrastructure Metrics

<CodeBlock title="Infrastructure monitoring" language="javascript">
{`// System-level metrics
const infrastructureMetrics = {
  // CPU metrics
  cpu: {
    usage: 'CPU utilization percentage',
    loadAverage: 'system load average',
    processes: 'running process count'
  },

  // Memory metrics
  memory: {
    usage: 'memory utilization percentage',
    available: 'available memory',
    heapUsage: 'Node.js heap usage',
    gcFrequency: 'garbage collection frequency'
  },

  // Disk metrics
  disk: {
    usage: 'disk space utilization',
    ioOperations: 'disk I/O operations per second',
    ioLatency: 'disk I/O latency'
  },

  // Network metrics
  network: {
    bandwidth: 'network bandwidth usage',
    connections: 'active network connections',
    latency: 'network latency'
  }
}`}
</CodeBlock>

## Implementing Metrics Collection

### Application-Level Monitoring

<CodeBlock title="src/lib/metrics.ts" language="typescript">
{`import { performance } from 'perf_hooks'

interface MetricData {
  name: string
  value: number
  timestamp: number
  tags?: Record<string, string>
}

class MetricsCollector {
  private metrics: MetricData[] = []
  private timers: Map<string, number> = new Map()

  // Counter metrics
  increment(name: string, value: number = 1, tags?: Record<string, string>) {
    this.metrics.push({
      name,
      value,
      timestamp: Date.now(),
      tags
    })
  }

  // Gauge metrics
  gauge(name: string, value: number, tags?: Record<string, string>) {
    this.metrics.push({
      name,
      value,
      timestamp: Date.now(),
      tags
    })
  }

  // Timing metrics
  startTimer(name: string) {
    this.timers.set(name, performance.now())
  }

  endTimer(name: string, tags?: Record<string, string>) {
    const startTime = this.timers.get(name)
    if (startTime) {
      const duration = performance.now() - startTime
      this.gauge(name, duration, tags)
      this.timers.delete(name)
    }
  }

  // Histogram metrics
  histogram(name: string, value: number, tags?: Record<string, string>) {
    this.metrics.push({
      name: \`\${name}_histogram\`,
      value,
      timestamp: Date.now(),
      tags
    })
  }

  // Get all metrics
  getMetrics(): MetricData[] {
    return [...this.metrics]
  }

  // Clear metrics
  clear() {
    this.metrics = []
  }

  // Export metrics in Prometheus format
  exportPrometheus(): string {
    const grouped = this.groupMetricsByName()
    let output = ''

    for (const [name, metrics] of grouped) {
      output += \`# HELP \${name} Application metric\\n\`
      output += \`# TYPE \${name} gauge\\n\`
      
      for (const metric of metrics) {
        const tags = metric.tags 
          ? Object.entries(metric.tags)
              .map(([k, v]) => \`\${k}="\${v}"\`)
              .join(',')
          : ''
        
        output += \`\${name}\${tags ? \`{\${tags}}\` : ''} \${metric.value} \${metric.timestamp}\\n\`
      }
    }

    return output
  }

  private groupMetricsByName(): Map<string, MetricData[]> {
    const grouped = new Map<string, MetricData[]>()
    
    for (const metric of this.metrics) {
      if (!grouped.has(metric.name)) {
        grouped.set(metric.name, [])
      }
      grouped.get(metric.name)!.push(metric)
    }

    return grouped
  }
}

export const metrics = new MetricsCollector()

// Middleware for automatic request tracking
export function metricsMiddleware(req: any, res: any, next: any) {
  const startTime = performance.now()
  const timerName = \`http_request_\${Date.now()}\`
  
  metrics.startTimer(timerName)
  metrics.increment('http_requests_total', 1, {
    method: req.method,
    route: req.route?.path || req.path
  })

  res.on('finish', () => {
    metrics.endTimer(timerName, {
      method: req.method,
      status: res.statusCode.toString(),
      route: req.route?.path || req.path
    })

    metrics.increment('http_requests_completed', 1, {
      method: req.method,
      status: res.statusCode.toString()
    })

    if (res.statusCode >= 400) {
      metrics.increment('http_errors_total', 1, {
        method: req.method,
        status: res.statusCode.toString()
      })
    }
  })

  next()
}`}
</CodeBlock>

### Metrics API Endpoint

<CodeBlock title="src/app/api/metrics/route.ts" language="typescript">
{`import { NextResponse } from 'next/server'
import { metrics } from '@/lib/metrics'

export async function GET() {
  try {
    // Collect current system metrics
    const systemMetrics = {
      memory: process.memoryUsage(),
      uptime: process.uptime(),
      cpu: process.cpuUsage(),
      version: process.version,
      platform: process.platform
    }

    // Add system metrics to collector
    metrics.gauge('nodejs_memory_heap_used_bytes', systemMetrics.memory.heapUsed)
    metrics.gauge('nodejs_memory_heap_total_bytes', systemMetrics.memory.heapTotal)
    metrics.gauge('nodejs_memory_external_bytes', systemMetrics.memory.external)
    metrics.gauge('nodejs_uptime_seconds', systemMetrics.uptime)

    // Return metrics in Prometheus format
    const prometheusMetrics = metrics.exportPrometheus()
    
    return new NextResponse(prometheusMetrics, {
      headers: {
        'Content-Type': 'text/plain; version=0.0.4; charset=utf-8'
      }
    })
  } catch (error) {
    console.error('Error collecting metrics:', error)
    return NextResponse.json(
      { error: 'Failed to collect metrics' },
      { status: 500 }
    )
  }
}

// Health check with metrics
export async function POST() {
  try {
    const healthData = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      checks: {
        database: await checkDatabase(),
        cache: await checkCache(),
        externalServices: await checkExternalServices()
      }
    }

    // Record health check metrics
    metrics.increment('health_checks_total', 1)
    
    Object.entries(healthData.checks).forEach(([service, status]) => {
      metrics.gauge('service_health', status === 'healthy' ? 1 : 0, {
        service
      })
    })

    return NextResponse.json(healthData)
  } catch (error) {
    metrics.increment('health_check_errors_total', 1)
    return NextResponse.json(
      { status: 'unhealthy', error: error.message },
      { status: 503 }
    )
  }
}

async function checkDatabase(): Promise<string> {
  // Implement database health check
  try {
    // Example: await db.query('SELECT 1')
    return 'healthy'
  } catch {
    return 'unhealthy'
  }
}

async function checkCache(): Promise<string> {
  // Implement cache health check
  try {
    // Example: await redis.ping()
    return 'healthy'
  } catch {
    return 'unhealthy'
  }
}

async function checkExternalServices(): Promise<string> {
  // Implement external service checks
  try {
    // Example: check API endpoints, third-party services
    return 'healthy'
  } catch {
    return 'unhealthy'
  }
}`}
</CodeBlock>

## Structured Logging

### Implementing Structured Logging

<CodeBlock title="src/lib/logger.ts" language="typescript">
{`import { metrics } from './metrics'

export enum LogLevel {
  ERROR = 0,
  WARN = 1,
  INFO = 2,
  DEBUG = 3
}

interface LogEntry {
  timestamp: string
  level: string
  message: string
  context?: string
  data?: any
  requestId?: string
  userId?: string
  sessionId?: string
  traceId?: string
  spanId?: string
}

class Logger {
  private level: LogLevel
  private context: string

  constructor(context: string = 'App', level: LogLevel = LogLevel.INFO) {
    this.context = context
    this.level = level
  }

  private shouldLog(level: LogLevel): boolean {
    return level <= this.level
  }

  private formatLog(level: LogLevel, message: string, data?: any): LogEntry {
    return {
      timestamp: new Date().toISOString(),
      level: LogLevel[level],
      message,
      context: this.context,
      ...(data && { data }),
      // Add request context if available
      requestId: this.getRequestId(),
      userId: this.getUserId(),
      sessionId: this.getSessionId(),
      traceId: this.getTraceId(),
      spanId: this.getSpanId()
    }
  }

  private output(logEntry: LogEntry) {
    const logString = JSON.stringify(logEntry)
    
    if (logEntry.level === 'ERROR') {
      console.error(logString)
      metrics.increment('log_entries_total', 1, { level: 'error' })
    } else if (logEntry.level === 'WARN') {
      console.warn(logString)
      metrics.increment('log_entries_total', 1, { level: 'warn' })
    } else {
      console.log(logString)
      metrics.increment('log_entries_total', 1, { level: logEntry.level.toLowerCase() })
    }
  }

  error(message: string, error?: Error | any) {
    if (!this.shouldLog(LogLevel.ERROR)) return

    const logData = error instanceof Error ? {
      name: error.name,
      message: error.message,
      stack: error.stack,
      ...(error.cause && { cause: error.cause })
    } : error

    this.output(this.formatLog(LogLevel.ERROR, message, logData))
  }

  warn(message: string, data?: any) {
    if (!this.shouldLog(LogLevel.WARN)) return
    this.output(this.formatLog(LogLevel.WARN, message, data))
  }

  info(message: string, data?: any) {
    if (!this.shouldLog(LogLevel.INFO)) return
    this.output(this.formatLog(LogLevel.INFO, message, data))
  }

  debug(message: string, data?: any) {
    if (!this.shouldLog(LogLevel.DEBUG)) return
    this.output(this.formatLog(LogLevel.DEBUG, message, data))
  }

  // Performance logging
  time(label: string, data?: any) {
    this.debug(\`Timer started: \${label}\`, data)
    console.time(label)
  }

  timeEnd(label: string, data?: any) {
    console.timeEnd(label)
    this.debug(\`Timer ended: \${label}\`, data)
  }

  // Request logging
  logRequest(req: any, res: any, duration: number) {
    this.info('HTTP Request', {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration: \`\${duration}ms\`,
      userAgent: req.headers['user-agent'],
      ip: req.headers['x-forwarded-for'] || req.connection?.remoteAddress,
      contentLength: res.get('content-length')
    })
  }

  // Business event logging
  logBusinessEvent(event: string, data?: any) {
    this.info(\`Business Event: \${event}\`, data)
    metrics.increment('business_events_total', 1, { event })
  }

  // Security event logging
  logSecurityEvent(event: string, data?: any) {
    this.warn(\`Security Event: \${event}\`, data)
    metrics.increment('security_events_total', 1, { event })
  }

  // Helper methods to get context (implement based on your setup)
  private getRequestId(): string | undefined {
    // Implementation depends on your request context setup
    return undefined
  }

  private getUserId(): string | undefined {
    // Implementation depends on your authentication setup
    return undefined
  }

  private getSessionId(): string | undefined {
    // Implementation depends on your session management
    return undefined
  }

  private getTraceId(): string | undefined {
    // Implementation depends on your tracing setup
    return undefined
  }

  private getSpanId(): string | undefined {
    // Implementation depends on your tracing setup
    return undefined
  }
}

export const logger = new Logger('NextApp', LogLevel.INFO)
export default Logger`}
</CodeBlock>

## Alerting and Notifications

### Alert Configuration

<CodeBlock title="Alert rules configuration" language="javascript">
{`// monitoring/alerts.js
module.exports = {
  alerts: [
    {
      name: 'High Error Rate',
      description: 'Application error rate is above threshold',
      condition: {
        metric: 'http_errors_total',
        operator: 'rate',
        threshold: 0.05, // 5% error rate
        duration: '5m'
      },
      severity: 'critical',
      notifications: ['email', 'slack'],
      runbook: 'https://docs.company.com/runbooks/high-error-rate'
    },

    {
      name: 'High Response Time',
      description: '95th percentile response time is too high',
      condition: {
        metric: 'http_request_duration_p95',
        operator: 'gt',
        threshold: 2000, // 2 seconds
        duration: '10m'
      },
      severity: 'warning',
      notifications: ['slack'],
      runbook: 'https://docs.company.com/runbooks/high-response-time'
    },

    {
      name: 'Memory Usage High',
      description: 'Application memory usage is approaching limits',
      condition: {
        metric: 'nodejs_memory_heap_used_bytes',
        operator: 'gt',
        threshold: 1073741824, // 1GB
        duration: '5m'
      },
      severity: 'warning',
      notifications: ['email'],
      runbook: 'https://docs.company.com/runbooks/memory-usage'
    },

    {
      name: 'Service Down',
      description: 'Application health check is failing',
      condition: {
        metric: 'service_health',
        operator: 'eq',
        threshold: 0,
        duration: '1m'
      },
      severity: 'critical',
      notifications: ['email', 'slack', 'pagerduty'],
      runbook: 'https://docs.company.com/runbooks/service-down'
    },

    {
      name: 'Disk Space Low',
      description: 'Disk space is running low',
      condition: {
        metric: 'disk_usage_percent',
        operator: 'gt',
        threshold: 85,
        duration: '15m'
      },
      severity: 'warning',
      notifications: ['email'],
      runbook: 'https://docs.company.com/runbooks/disk-space'
    }
  ],

  notifications: {
    email: {
      enabled: true,
      recipients: ['devops@company.com', 'oncall@company.com'],
      smtp: {
        host: process.env.SMTP_HOST,
        port: 587,
        secure: false,
        auth: {
          user: process.env.SMTP_USER,
          pass: process.env.SMTP_PASS
        }
      }
    },

    slack: {
      enabled: true,
      webhook: process.env.SLACK_WEBHOOK_URL,
      channel: '#alerts',
      username: 'NextDeploy Monitor'
    },

    pagerduty: {
      enabled: true,
      integrationKey: process.env.PAGERDUTY_INTEGRATION_KEY,
      severity: 'critical'
    }
  }
}`}
</CodeBlock>

### Alert Manager Implementation

<CodeBlock title="src/lib/alerting.ts" language="typescript">
{`import { logger } from './logger'
import { metrics } from './metrics'

interface Alert {
  name: string
  description: string
  severity: 'info' | 'warning' | 'critical'
  timestamp: number
  value: number
  threshold: number
  runbook?: string
}

interface NotificationChannel {
  type: 'email' | 'slack' | 'webhook'
  config: any
}

class AlertManager {
  private activeAlerts: Map<string, Alert> = new Map()
  private alertHistory: Alert[] = []

  async checkAlert(
    name: string,
    value: number,
    threshold: number,
    operator: 'gt' | 'lt' | 'eq' | 'ne' = 'gt',
    severity: 'info' | 'warning' | 'critical' = 'warning'
  ) {
    const isTriggered = this.evaluateCondition(value, threshold, operator)
    const alertKey = \`\${name}_\${severity}\`

    if (isTriggered && !this.activeAlerts.has(alertKey)) {
      // New alert triggered
      const alert: Alert = {
        name,
        description: \`\${name} threshold exceeded\`,
        severity,
        timestamp: Date.now(),
        value,
        threshold
      }

      this.activeAlerts.set(alertKey, alert)
      this.alertHistory.push(alert)
      
      await this.sendNotification(alert)
      
      logger.warn('Alert triggered', {
        alert: alertKey,
        value,
        threshold,
        severity
      })

      metrics.increment('alerts_triggered_total', 1, {
        alert: name,
        severity
      })

    } else if (!isTriggered && this.activeAlerts.has(alertKey)) {
      // Alert resolved
      const alert = this.activeAlerts.get(alertKey)!
      this.activeAlerts.delete(alertKey)
      
      await this.sendResolutionNotification(alert)
      
      logger.info('Alert resolved', {
        alert: alertKey,
        value,
        threshold
      })

      metrics.increment('alerts_resolved_total', 1, {
        alert: name,
        severity
      })
    }
  }

  private evaluateCondition(
    value: number,
    threshold: number,
    operator: 'gt' | 'lt' | 'eq' | 'ne'
  ): boolean {
    switch (operator) {
      case 'gt': return value > threshold
      case 'lt': return value < threshold
      case 'eq': return value === threshold
      case 'ne': return value !== threshold
      default: return false
    }
  }

  private async sendNotification(alert: Alert) {
    const channels = this.getNotificationChannels(alert.severity)
    
    for (const channel of channels) {
      try {
        await this.sendToChannel(channel, alert)
      } catch (error) {
        logger.error('Failed to send alert notification', {
          channel: channel.type,
          alert: alert.name,
          error
        })
      }
    }
  }

  private async sendResolutionNotification(alert: Alert) {
    const channels = this.getNotificationChannels(alert.severity)
    
    for (const channel of channels) {
      try {
        await this.sendResolutionToChannel(channel, alert)
      } catch (error) {
        logger.error('Failed to send resolution notification', {
          channel: channel.type,
          alert: alert.name,
          error
        })
      }
    }
  }

  private getNotificationChannels(severity: string): NotificationChannel[] {
    const channels: NotificationChannel[] = []

    // Always send to email for critical alerts
    if (severity === 'critical') {
      channels.push({
        type: 'email',
        config: {
          recipients: ['oncall@company.com'],
          subject: 'CRITICAL ALERT'
        }
      })
    }

    // Send to Slack for all alerts
    channels.push({
      type: 'slack',
      config: {
        webhook: process.env.SLACK_WEBHOOK_URL,
        channel: '#alerts'
      }
    })

    return channels
  }

  private async sendToChannel(channel: NotificationChannel, alert: Alert) {
    switch (channel.type) {
      case 'email':
        await this.sendEmail(channel.config, alert)
        break
      case 'slack':
        await this.sendSlack(channel.config, alert)
        break
      case 'webhook':
        await this.sendWebhook(channel.config, alert)
        break
    }
  }

  private async sendResolutionToChannel(channel: NotificationChannel, alert: Alert) {
    // Similar to sendToChannel but for resolution messages
    const resolutionMessage = \`âœ… RESOLVED: \${alert.name}\`
    // Implementation details...
  }

  private async sendEmail(config: any, alert: Alert) {
    // Email implementation
    logger.debug('Sending email alert', { alert: alert.name })
  }

  private async sendSlack(config: any, alert: Alert) {
    const payload = {
      channel: config.channel,
      username: 'NextDeploy Monitor',
      icon_emoji: alert.severity === 'critical' ? ':rotating_light:' : ':warning:',
      attachments: [{
        color: alert.severity === 'critical' ? 'danger' : 'warning',
        title: \`\${alert.severity.toUpperCase()}: \${alert.name}\`,
        text: alert.description,
        fields: [
          {
            title: 'Value',
            value: alert.value.toString(),
            short: true
          },
          {
            title: 'Threshold',
            value: alert.threshold.toString(),
            short: true
          },
          {
            title: 'Time',
            value: new Date(alert.timestamp).toISOString(),
            short: true
          }
        ]
      }]
    }

    const response = await fetch(config.webhook, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })

    if (!response.ok) {
      throw new Error(\`Slack notification failed: \${response.statusText}\`)
    }
  }

  private async sendWebhook(config: any, alert: Alert) {
    // Webhook implementation
    logger.debug('Sending webhook alert', { alert: alert.name })
  }

  getActiveAlerts(): Alert[] {
    return Array.from(this.activeAlerts.values())
  }

  getAlertHistory(limit: number = 100): Alert[] {
    return this.alertHistory.slice(-limit)
  }
}

export const alertManager = new AlertManager()`}
</CodeBlock>

## Dashboard Creation

### Monitoring Dashboard

<CodeBlock title="src/app/admin/monitoring/page.tsx" language="typescript">
{`'use client'

import { useEffect, useState } from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Progress } from '@/components/ui/progress'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { Activity, Server, Zap, AlertTriangle, CheckCircle, Clock, TrendingUp, TrendingDown } from 'lucide-react'

interface SystemMetrics {
  timestamp: string
  application: {
    responseTime: {
      p50: number
      p95: number
      p99: number
    }
    throughput: {
      requestsPerSecond: number
      requestsPerMinute: number
    }
    errors: {
      rate: number
      total: number
    }
  }
  infrastructure: {
    cpu: {
      usage: number
      loadAverage: number[]
    }
    memory: {
      usage: number
      total: number
      used: number
    }
    disk: {
      usage: number
      total: number
      used: number
    }
  }
  health: {
    status: 'healthy' | 'degraded' | 'unhealthy'
    checks: Record<string, boolean>
  }
}

interface AlertData {
  name: string
  severity: 'info' | 'warning' | 'critical'
  description: string
  timestamp: number
  active: boolean
}

export default function MonitoringDashboard() {
  const [metrics, setMetrics] = useState<SystemMetrics | null>(null)
  const [alerts, setAlerts] = useState<AlertData[]>([])
  const [loading, setLoading] = useState(true)
  const [lastUpdate, setLastUpdate] = useState<Date>(new Date())

  useEffect(() => {
    const fetchData = async () => {
      try {
        const [metricsResponse, alertsResponse] = await Promise.all([
          fetch('/api/metrics/dashboard'),
          fetch('/api/alerts')
        ])

        const metricsData = await metricsResponse.json()
        const alertsData = await alertsResponse.json()

        setMetrics(metricsData)
        setAlerts(alertsData)
        setLastUpdate(new Date())
      } catch (error) {
        console.error('Failed to fetch monitoring data:', error)
      } finally {
        setLoading(false)
      }
    }

    fetchData()
    const interval = setInterval(fetchData, 30000) // Update every 30 seconds

    return () => clearInterval(interval)
  }, [])

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <Activity className="h-8 w-8 animate-spin mx-auto mb-4" />
          <p>Loading monitoring data...</p>
        </div>
      </div>
    )
  }

  if (!metrics) {
    return (
      <div className="flex items-center justify-center h-64">
        <Alert>
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>
            Failed to load monitoring data. Please check your connection and try again.
          </AlertDescription>
        </Alert>
      </div>
    )
  }

  const getHealthStatusColor = (status: string) => {
    switch (status) {
      case 'healthy': return 'text-green-600'
      case 'degraded': return 'text-yellow-600'
      case 'unhealthy': return 'text-red-600'
      default: return 'text-gray-600'
    }
  }

  const getHealthStatusIcon = (status: string) => {
    switch (status) {
      case 'healthy': return <CheckCircle className="h-4 w-4 text-green-600" />
      case 'degraded': return <AlertTriangle className="h-4 w-4 text-yellow-600" />
      case 'unhealthy': return <AlertTriangle className="h-4 w-4 text-red-600" />
      default: return <Server className="h-4 w-4 text-gray-600" />
    }
  }

  const formatBytes = (bytes: number) => {
    const gb = bytes / 1024 / 1024 / 1024
    return `${gb.toFixed(1)} GB`
  }

  const formatPercentage = (value: number) => {
    return `${value.toFixed(1)}%`
  }

  const activeAlerts = alerts.filter(alert => alert.active)
  const criticalAlerts = activeAlerts.filter(alert => alert.severity === 'critical')

  return (
    <div className="container mx-auto py-8 space-y-8">
      {/* Header */}
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold">System Monitoring</h1>
          <p className="text-muted-foreground">
            Last updated: {lastUpdate.toLocaleTimeString()}
          </p>
        </div>
        <div className="flex items-center space-x-2">
          {getHealthStatusIcon(metrics.health.status)}
          <span className={`font-medium ${getHealthStatusColor(metrics.health.status)}`}>
            {metrics.health.status.toUpperCase()}
          </span>
        </div>
      </div>

      {/* Active Alerts */}
      {activeAlerts.length > 0 && (
        <div className="space-y-4">
          <h2 className="text-xl font-semibold flex items-center">
            <AlertTriangle className="h-5 w-5 mr-2 text-red-600" />
            Active Alerts ({activeAlerts.length})
          </h2>
          <div className="grid gap-4">
            {activeAlerts.map((alert, index) => (
              <Alert key={index} className={`border-l-4 ${
                alert.severity === 'critical' ? 'border-l-red-500 bg-red-50 dark:bg-red-900/10' :
                alert.severity === 'warning' ? 'border-l-yellow-500 bg-yellow-50 dark:bg-yellow-900/10' :
                'border-l-blue-500 bg-blue-50 dark:bg-blue-900/10'
              }`}>
                <div className="flex justify-between items-start">
                  <div>
                    <div className="flex items-center space-x-2">
                      <Badge variant={alert.severity === 'critical' ? 'destructive' : 'secondary'}>
                        {alert.severity.toUpperCase()}
                      </Badge>
                      <span className="font-semibold">{alert.name}</span>
                    </div>
                    <AlertDescription className="mt-1">
                      {alert.description}
                    </AlertDescription>
                  </div>
                  <div className="text-sm text-muted-foreground">
                    {new Date(alert.timestamp).toLocaleTimeString()}
                  </div>
                </div>
              </Alert>
            ))}
          </div>
        </div>
      )}

      {/* Key Metrics Overview */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        {/* Response Time */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Response Time (P95)</CardTitle>
            <Zap className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {metrics.application.responseTime.p95}ms
            </div>
            <div className="flex items-center text-xs text-muted-foreground mt-1">
              {metrics.application.responseTime.p95 < 1000 ? (
                <TrendingDown className="h-3 w-3 text-green-600 mr-1" />
              ) : (
                <TrendingUp className="h-3 w-3 text-red-600 mr-1" />
              )}
              P50: {metrics.application.responseTime.p50}ms
            </div>
          </CardContent>
        </Card>

        {/* Throughput */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Requests/sec</CardTitle>
            <Activity className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {metrics.application.throughput.requestsPerSecond}
            </div>
            <p className="text-xs text-muted-foreground">
              {metrics.application.throughput.requestsPerMinute}/min
            </p>
          </CardContent>
        </Card>

        {/* Error Rate */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Error Rate</CardTitle>
            <AlertTriangle className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {formatPercentage(metrics.application.errors.rate)}
            </div>
            <p className="text-xs text-muted-foreground">
              {metrics.application.errors.total} total errors
            </p>
          </CardContent>
        </Card>

        {/* System Health */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">System Health</CardTitle>
            <Server className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className={`text-2xl font-bold ${getHealthStatusColor(metrics.health.status)}`}>
              {metrics.health.status}
            </div>
            <p className="text-xs text-muted-foreground">
              {Object.values(metrics.health.checks).filter(Boolean).length}/
              {Object.keys(metrics.health.checks).length} services healthy
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Resource Usage */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* CPU Usage */}
        <Card>
          <CardHeader>
            <CardTitle>CPU Usage</CardTitle>
            <CardDescription>Current CPU utilization</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex justify-between text-sm">
              <span>Usage</span>
              <span>{formatPercentage(metrics.infrastructure.cpu.usage)}</span>
            </div>
            <Progress value={metrics.infrastructure.cpu.usage} className="h-2" />
            <div className="text-xs text-muted-foreground">
              Load Average: {metrics.infrastructure.cpu.loadAverage.map(l => l.toFixed(2)).join(', ')}
            </div>
          </CardContent>
        </Card>

        {/* Memory Usage */}
        <Card>
          <CardHeader>
            <CardTitle>Memory Usage</CardTitle>
            <CardDescription>RAM utilization</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex justify-between text-sm">
              <span>Used</span>
              <span>{formatBytes(metrics.infrastructure.memory.used)} / {formatBytes(metrics.infrastructure.memory.total)}</span>
            </div>
            <Progress value={metrics.infrastructure.memory.usage} className="h-2" />
            <div className="text-xs text-muted-foreground">
              {formatPercentage(metrics.infrastructure.memory.usage)} utilized
            </div>
          </CardContent>
        </Card>

        {/* Disk Usage */}
        <Card>
          <CardHeader>
            <CardTitle>Disk Usage</CardTitle>
            <CardDescription>Storage utilization</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex justify-between text-sm">
              <span>Used</span>
              <span>{formatBytes(metrics.infrastructure.disk.used)} / {formatBytes(metrics.infrastructure.disk.total)}</span>
            </div>
            <Progress value={metrics.infrastructure.disk.usage} className="h-2" />
            <div className="text-xs text-muted-foreground">
              {formatPercentage(metrics.infrastructure.disk.usage)} utilized
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Service Health Checks */}
      <Card>
        <CardHeader>
          <CardTitle>Service Health Checks</CardTitle>
          <CardDescription>Status of individual service components</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
            {Object.entries(metrics.health.checks).map(([service, healthy]) => (
              <div key={service} className="flex items-center space-x-2">
                {healthy ? (
                  <CheckCircle className="h-4 w-4 text-green-600" />
                ) : (
                  <AlertTriangle className="h-4 w-4 text-red-600" />
                )}
                <span className="text-sm capitalize">{service}</span>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}`}
</CodeBlock>

## Performance Optimization Based on Metrics

### Automated Performance Tuning

<CodeBlock title="src/lib/performance-optimizer.ts" language="typescript">
{`import { metrics } from './metrics'
import { logger } from './logger'
import { alertManager } from './alerting'

interface OptimizationRule {
  name: string
  condition: (metrics: any) => boolean
  action: () => Promise<void>
  cooldown: number // milliseconds
  lastExecuted?: number
}

class PerformanceOptimizer {
  private rules: OptimizationRule[] = []
  private isRunning = false

  constructor() {
    this.setupOptimizationRules()
  }

  private setupOptimizationRules() {
    this.rules = [
      {
        name: 'Memory Cleanup',
        condition: (metrics) => metrics.memory.heapUsed > 500 * 1024 * 1024, // 500MB
        action: this.performMemoryCleanup,
        cooldown: 5 * 60 * 1000 // 5 minutes
      },
      {
        name: 'Cache Optimization',
        condition: (metrics) => metrics.responseTime.p95 > 2000, // 2 seconds
        action: this.optimizeCache,
        cooldown: 10 * 60 * 1000 // 10 minutes
      },
      {
        name: 'Connection Pool Adjustment',
        condition: (metrics) => metrics.activeConnections > 100,
        action: this.adjustConnectionPool,
        cooldown: 15 * 60 * 1000 // 15 minutes
      }
    ]
  }

  async runOptimizations() {
    if (this.isRunning) return

    this.isRunning = true
    
    try {
      const currentMetrics = await this.getCurrentMetrics()
      
      for (const rule of this.rules) {
        if (this.shouldExecuteRule(rule, currentMetrics)) {
          await this.executeRule(rule)
        }
      }
    } catch (error) {
      logger.error('Performance optimization failed', error)
    } finally {
      this.isRunning = false
    }
  }

  private shouldExecuteRule(rule: OptimizationRule, metrics: any): boolean {
    // Check if condition is met
    if (!rule.condition(metrics)) return false

    // Check cooldown period
    if (rule.lastExecuted && Date.now() - rule.lastExecuted < rule.cooldown) {
      return false
    }

    return true
  }

  private async executeRule(rule: OptimizationRule) {
    try {
      logger.info(`Executing optimization rule: ${rule.name}`)
      
      await rule.action()
      
      rule.lastExecuted = Date.now()
      
      metrics.increment('optimizations_executed_total', 1, {
        rule: rule.name
      })
      
      logger.info(`Optimization rule completed: ${rule.name}`)
    } catch (error) {
      logger.error(`Optimization rule failed: ${rule.name}`, error)
      
      metrics.increment('optimizations_failed_total', 1, {
        rule: rule.name
      })
    }
  }

  private async getCurrentMetrics() {
    return {
      memory: process.memoryUsage(),
      responseTime: await this.getResponseTimeMetrics(),
      activeConnections: await this.getActiveConnections()
    }
  }

  private async getResponseTimeMetrics() {
    // Implementation to get current response time metrics
    return { p95: 1500 } // placeholder
  }

  private async getActiveConnections() {
    // Implementation to get active connection count
    return 50 // placeholder
  }

  private async performMemoryCleanup() {
    logger.info('Performing memory cleanup')
    
    // Force garbage collection if available
    if (global.gc) {
      global.gc()
    }
    
    // Clear application caches
    await this.clearApplicationCaches()
    
    // Log memory usage after cleanup
    const memoryAfter = process.memoryUsage()
    logger.info('Memory cleanup completed', {
      heapUsed: memoryAfter.heapUsed,
      heapTotal: memoryAfter.heapTotal
    })
  }

  private async optimizeCache() {
    logger.info('Optimizing cache performance')
    
    // Implement cache optimization logic
    // This could include:
    // - Preloading frequently accessed data
    // - Adjusting cache TTL values
    // - Clearing stale cache entries
    
    logger.info('Cache optimization completed')
  }

  private async adjustConnectionPool() {
    logger.info('Adjusting connection pool settings')
    
    // Implement connection pool optimization
    // This could include:
    // - Increasing pool size
    // - Adjusting timeout values
    // - Closing idle connections
    
    logger.info('Connection pool adjustment completed')
  }

  private async clearApplicationCaches() {
    // Implementation to clear various application caches
    logger.debug('Clearing application caches')
  }
}

export const performanceOptimizer = new PerformanceOptimizer()

// Schedule regular optimization runs
setInterval(() => {
  performanceOptimizer.runOptimizations()
}, 5 * 60 * 1000) // Run every 5 minutes`}
</CodeBlock>

## Conclusion

Effective monitoring is crucial for maintaining healthy production applications. By implementing comprehensive metrics collection, structured logging, proactive alerting, and automated optimization, you can:

<Success>
- **Detect issues before they impact users**
- **Understand application performance patterns**
- **Make data-driven optimization decisions**
- **Maintain high availability and reliability**
- **Reduce mean time to resolution (MTTR)**
</Success>

## Best Practices Summary

1. **Monitor the Right Metrics**: Focus on user-impacting metrics like response time, error rate, and availability
2. **Set Meaningful Alerts**: Avoid alert fatigue by setting appropriate thresholds and using escalation policies
3. **Use Structured Logging**: Make logs searchable and actionable with consistent structure
4. **Implement Health Checks**: Provide detailed health information for automated monitoring
5. **Plan for Scale**: Design monitoring systems that can handle growth in traffic and data
6. **Document Runbooks**: Provide clear procedures for responding to alerts
7. **Regular Review**: Continuously evaluate and improve your monitoring strategy

## Next Steps

1. **Implement basic metrics collection** in your Next.js application
2. **Set up structured logging** with appropriate log levels
3. **Configure essential alerts** for critical system metrics
4. **Create monitoring dashboards** for visibility
5. **Establish incident response procedures** with clear runbooks
6. **Test your monitoring** with chaos engineering practices

Ready to implement comprehensive monitoring? Check out our [VPS Deployment Course](/courses/deploying-nextjs-to-vps) where we cover monitoring setup in detail, or explore our [Infrastructure as Code guide](/blog/infrastructure-as-code-best-practices) for managing monitoring configuration.

Remember: monitoring is not a one-time setupâ€”it's an ongoing practice that evolves with your application and business needs.
\`\`\`

Now let me update the components to read from these MDX files:

\`\`\`
